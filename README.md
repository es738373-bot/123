1)Задача: реализовать локальный поиск для нахождения приближенного решения задачи о
независимом множестве
2) Алгоритм: read_graph() — ввод графа
  a)Спрашиваем у пользователя количество вершин (жёсткое ограничение: ровно 12).
    Принимает рёбра в формате u v (номера вершин через пробел).Строим список смежности : для каждой вершины хранит список соседних.

Особенности:

Граф неориентированный: ребро u–v добавляется в оба списка (adj_list[u] и adj_list[v]).

Валидация ввода: проверка диапазонов вершин и формата.

  b). — проверяем независимости (is_independent_set(vertices, adj_list)) 


  c). проверка возможности добавления(can_add_vertex(v, current_set, adj_list))


 d).Жадно строиь независимое множество, рассматривая вершины в случайном порядке. Это даёт разные результаты при разных запусках — так реализуется «локальный поиск». (local_search_independent_set(adj_list)) 
  

Шаги:

1)Создаёт пустое множество current_set.

2)Берёт список всех вершин (0..11) и перемешивает его случайным образом.

3)Для каждой вершины v в перемешанном порядке:

Если v ещё не в множестве и её можно добавить (по can_add_vertex) — добавляет.

4)Возвращает отсортированный список вершин и его размер.

5)Временная сложнось: O(n²)
Почему именно O(n²)?
Фиксированное n = 12

Хотя асимптотика O(n²), на практике n константно, поэтому алгоритм работает очень быстро.

Максимальное число рёбер: 12 · 11 / 2 = 66.

Цикл в local_search выполнит не более 12 итераций, каждая — не более 11 проверок соседей.

Ключевой узкий место

Вложенный цикл в local_search: для каждой вершины проверяем её соседей.

В худшем случае (полный граф) каждая вершина имеет 11 соседей → 12 · 11 = 132 операций.

Структура данных

Использование set() для current_set гарантирует O(1) на проверку принадлежности.

Если бы использовался список, сложность выросла бы до O(n³) из‑за if neighbor in current_set за O(n).





2) Условие. Даны предметы с весами wi и контейнеры вместимостью W. Упаковать все
предметы в минимальное число контейнеров (жадно).
Алгоритм: первый подходящий (First‑Fit).

2)Инициализация
1)Создаётся список bins, где каждый элемент — текущая загрузка одного контейнера (изначально контейнеров нет).(bins)

2)бработка каждого предмета
Для каждого веса w из массива weights:

П3)Проходим по существующим контейнерам (bins) в порядке их создания (от первого к последнему).(bins(set))
    

4)Если нельзя ни в один существующий контейнер — создаём новый контейнер, кладя в него этот предмет (bins.add(w)).

Результат
Возвращается количество контейнеров: bins.size()
Временная сложность:O(n²).
Сложность O(n · n) возникает из-за:

n итераций по предметам,

до n проверок контейнеров на каждый предмет,

O(1)-операций внутри циклов.

В худшем случае (каждый предмет в отдельном контейнере) сложность деградирует до O(n²).
