1. read_graph() — ввод графа
Что делает:

Спрашивает у пользователя количество вершин (жёсткое ограничение: ровно 12).

Принимает рёбра в формате u v (номера вершин через пробел).

Завершение ввода — слово end.

Строит список смежности adj_list: для каждой вершины хранит список соседних.

Особенности:

Граф неориентированный: ребро u–v добавляется в оба списка (adj_list[u] и adj_list[v]).

Валидация ввода: проверка диапазонов вершин и формата.

2. is_independent_set(vertices, adj_list) — проверка независимости
Что делает:

Для каждого узла из vertices проверяет, есть ли среди его соседей другой узел из этого же набора.

Если хотя бы одно ребро внутри множества — возвращает False.

Иначе — True.

Пример:
Для множества {0, 2} и ребра 0–2 вернёт False.

3. can_add_vertex(v, current_set, adj_list) — проверка возможности добавления
Что делает:

Проверяет, можно ли добавить вершину v в уже имеющееся независимое множество current_set.

Для этого перебирает всех соседей v и смотрит, нет ли среди них вершин из current_set.

Если сосед уже в множестве — добавлять нельзя (False).

Иначе — можно (True).

4. local_search_independent_set(adj_list) — основной алгоритм
Идея:
Жадно строить независимое множество, рассматривая вершины в случайном порядке. Это даёт разные результаты при разных запусках — так реализуется «локальный поиск».

Шаги:

Создаёт пустое множество current_set.

Берёт список всех вершин (0..11) и перемешивает его случайным образом.

Для каждой вершины v в перемешанном порядке:

Если v ещё не в множестве и её можно добавить (по can_add_vertex) — добавляет.

Возвращает отсортированный список вершин и его размер.

Временная сложнось: O(n²)
Почему именно O(n²)?
Фиксированное n = 12

Хотя асимптотика O(n²), на практике n константно, поэтому алгоритм работает очень быстро.

Максимальное число рёбер: 12 · 11 / 2 = 66.

Цикл в local_search выполнит не более 12 итераций, каждая — не более 11 проверок соседей.

Ключевой узкий место

Вложенный цикл в local_search: для каждой вершины проверяем её соседей.

В худшем случае (полный граф) каждая вершина имеет 11 соседей → 12 · 11 = 132 операций.

Структура данных

Использование set() для current_set гарантирует O(1) на проверку принадлежности.

Если бы использовался список, сложность выросла бы до O(n³) из‑за if neighbor in current_set за O(n).




2)Инициализация
Создаётся список bins, где каждый элемент — текущая загрузка одного контейнера (изначально контейнеров нет).

Обработка каждого предмета
Для каждого веса w из массива weights:

Проходим по существующим контейнерам (bins) в порядке их создания (от первого к последнему).

Проверяем, можно ли положить предмет в контейнер: bins.get(i) + w ≤ W.

Если можно — добавляем предмет в этот контейнер (bins.set(i, ...)), отмечаем, что предмет упакован (packed = true), и выходим из цикла.

Если нельзя ни в один существующий контейнер — создаём новый контейнер, кладя в него этот предмет (bins.add(w)).

Результат
Возвращается количество контейнеров: bins.size()
Временная сложность:O(n²).
Сложность O(n · n) возникает из-за:

n итераций по предметам,

до n проверок контейнеров на каждый предмет,

O(1)-операций внутри циклов.

В худшем случае (каждый предмет в отдельном контейнере) сложность деградирует до O(n²).
